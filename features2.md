Bormotoon, [13.01.2026 10:49]
Ниже — подробный TODO‑план, разбитый на эпики и задачи, чтобы это можно было разложить по тикетам и последовательно внедрить. План рассчитан на реализацию в типичной контейнеризованной/DevOps‑схеме разработки и деплоя (как обычно удобнее для инфраструктурных сервисов и ботов). 

## Подготовка и решения
- Зафиксировать целевое поведение напоминаний:
  - Какие типы напоминаний есть (например, “за N часов до записи”, “в день записи в 09:00”, и т.п.).
  - Какая “12:00” имеется в виду: локальное время сервиса, МСК, или таймзона пользователя.
  - Что считать “отправленным уведомлением”: факт успешного вызова API Telegram или постановка в очередь.
- Зафиксировать ограничения Telegram:
  - Лимит сообщений в секунду/минуту для бота (принять целевой rate limit).
  - Политику повторных попыток (retry) и дедупликации.
- Принять архитектурное решение по БД:
  - “Переезд на Postgres” — отдельный эпик (с миграцией и рисками) или пока оставить текущую БД и сделать очистку приложением.
  - TTL “в Postgres” уточнить: будет ли это partitioning+DROP/DELETE по времени, pg_cron, TimescaleDB retention или приложение.

## Данные и миграции
- Описать текущие таблицы и поля (минимум: bookings/requests, reminders/notifications).
  - Выписать поля, которые “есть сейчас” в контракте бронирования (включая comment), и сверить с фактической схемой/DTO.
- Доработка модели бронирования под диапазоны (вечная/долгая аренда):
  - Добавить поле end_time (nullable) в сущность заявки/бронирования.
  - Правило по умолчанию: если end_time null → трактовать как равно start_time (одноразовая заявка).
  - Определить, как хранить “пул дат” от менеджера:
    - Вариант A: одна запись с диапазоном start_time..end_time.
    - Вариант B (если нужно точное разреженное множество дат): оставить “пул дат” как отдельные записи или отдельная таблица дат.
- Миграции данных:
  - Backfill: для всех существующих заявок проставить end_time = start_time (или оставить null и учитывать в коде).
  - Обновить индексы:
    - Индекс по start_time, end_time (и по item_id, если есть).
    - Если есть выборка “по дате” — продумать индекс под пересечение диапазонов.
- Таблица напоминаний (если нужно уточнить/улучшить):
  - Убедиться, что есть поля, позволяющие:
    - Выключить напоминание пользователем (флаг enabled/disabled).
    - Не отправлять повторно (sent_at / status).
    - Планировать отправку (send_after / scheduled_at).
    - Делать дедуп по (user_id, booking_id, reminder_type).

## Напоминания: cron + отправка
- Cron-задача “ежедневный проход в 12:00”:
  - Реализовать планировщик (cron внутри контейнера, отдельный worker, либо системный cron на хосте, либо job в оркестраторе).
  - Выборка из таблицы напоминаний:
    - Только активные (enabled=true).
    - Только те, что “пора отправлять” (по scheduled_at <= now).
    - Исключить уже отправленные (sent_at is null или status != SENT).
- Механизм отправки “с задержкой” (anti-spam):
  - Реализовать rate limiter:
    - Простой вариант: отправлять пачками по N сообщений, sleep между сообщениями/пачками.
    - Надёжный вариант: очередь задач (например, Redis/Rabbit) + воркер с ограничением скорости.
  - Гарантии:
    - Идемпотентность: повторный запуск крона не должен дублировать уведомления.
    - Retry: при ошибке Telegram пометить как FAILED и попробовать позже (ограничить число попыток).
- Логирование и наблюдаемость:
  - Логировать количество выбранных напоминаний, отправленных, пропущенных, ошибок.
  - Метрики (минимум): sent_count, failed_count, duration, backlog_size.
- Очистка таблицы напоминаний:
  - Ежедневная очистка записей старше 1 дня (или старше “окна полезности”).
  - Правило удаления:
    - После успешной отправки можно удалять сразу или хранить 1 день для аудита/дедупликации.
  - AC (критерии готовности):
    - После отправки напоминания повторной отправки не происходит даже при рестарте сервиса.
    - Отключённые пользователем напоминания не отправляются.
    - При массовой рассылке бот не ловит бан/флуд (rate limit соблюдается).

Bormotoon, [13.01.2026 10:49]
## API и конфиги
- Endpoint занятости/доступности items:
  - Привести к одному контракту (сейчас в тексте конфликт: путь “GET /api/items”, но метод “POST”).
  - Реализовать POST /api/items (или /api/items/availability) с телом:
    - start_date / end_date (или datetime), формат ISO 8601.
    - (опционально) фильтры: item_ids, cabinet_id, category.
  - Ответ:
    - Список items: id, name.
    - Для каждого item — массив дат/слотов с меткой busy/free (или available: true/false).
  - Логика занятости для диапазонных заявок:
    - Заявка с start_time..end_time перекрывает все даты/слоты внутри диапазона.
    - Уточнить, что считать конфликтом (пересечение по времени/дате, включительно/исключительно).
- Авторизация API key:
  - Добавить чтение ключа из заголовка (например, X-API-Key).
  - Валидация и единая ошибка 401/403.
  - Хранение ключей: env/secret manager, не в git.
- Контракт бронирования:
  - В DTO/Swagger/схеме добавить все существующие поля (включая comment).
  - Сверить, что клиент/бот эти поля корректно передаёт/читает.
- Кабинеты (как items.yaml):
  - Определить формат (например, cabinets.yaml или раздел в items.yaml):
    - id (для сортировки), name, number, address, description.
  - Загрузка конфига:
    - Валидация схемы при старте (ошибка, если невалидно).
    - Горячая перезагрузка не обязательна, но можно запланировать.
  - Использование:
    - Привязка items → cabinet_id (если требуется отображать аппараты по кабинетам).

## Тесты и выкладка
- Тесты:
  - Юнит‑тесты:
    - Пересечение диапазонов бронирования.
    - Правила “end_time null = start_time”.
    - Дедуп/идемпотентность отправки напоминаний.
  - Интеграционные:
    - Cron job выбирает правильные записи и меняет статус.
    - API availability возвращает корректные busy/free на наборе фикстур.
- Миграции и обратимость:
  - Скрипт миграции schema + data backfill.
  - Rollback‑план: как откатиться, если новый end_time ломает старые клиенты.
- Деплой:
  - Добавить отдельный worker/cron контейнер (если выбран такой вариант).
  - Настроить расписание запуска (12:00) и таймзону.
  - Добавить алерты на рост FAILED/очереди, и на отсутствие отправок в ожидаемое окно.