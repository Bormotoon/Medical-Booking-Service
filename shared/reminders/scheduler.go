package reminders
package reminders




























































































































































































































































































































}	return s.running	defer s.mu.Unlock()	s.mu.Lock()func (s *Scheduler) IsRunning() bool {// IsRunning returns whether the scheduler is currently running.}	return time.Date(2000, 1, 1, s.config.DailyHour, s.config.DailyMinute, 0, 0, time.UTC).Format("15:04")func (s *Scheduler) formatTime() string {// formatTime returns the scheduled time as a string.}	}		s.cleanupOldReminders(ctx)	if s.config.CleanupEnabled {	s.processDailyReminders(ctx)	s.logger.Info("manual reminder processing triggered")func (s *Scheduler) RunNow(ctx context.Context) {// RunNow forces an immediate run of the reminder processing.}	}		s.logger.Info("cleaned up old failed reminders", "deleted", deleted)	} else if deleted > 0 {		s.logger.Error("failed to cleanup failed reminders", "error", err)	if err != nil {	deleted, err = s.service.repo.DeleteReminders(ctx, failedFilter)	}		SentBefore: &failedCutoff,		Status:     []ReminderStatus{ReminderStatusFailed},	failedFilter := ReminderFilter{	failedCutoff := time.Now().Add(-3 * 24 * time.Hour)	// Delete failed reminders older than 3 days	}		s.logger.Info("cleaned up old sent reminders", "deleted", deleted)	} else if deleted > 0 {		s.logger.Error("failed to cleanup sent reminders", "error", err)	if err != nil {	deleted, err := s.service.repo.DeleteReminders(ctx, sentFilter)	}		SentBefore: &cutoff,		Status:     []ReminderStatus{ReminderStatusSent},	sentFilter := ReminderFilter{	// Delete sent reminders older than retention period	cutoff := time.Now().Add(-retention)	retention := time.Duration(s.config.CleanupRetentionDays) * 24 * time.Hourfunc (s *Scheduler) cleanupOldReminders(ctx context.Context) {// cleanupOldReminders removes old sent/failed reminders.}	return s.sender.SendWithRetry(ctx, r, booking)	// Send with retry	}		return s.service.repo.UpdateReminder(ctx, r)		r.UpdatedAt = time.Now()		r.Status = ReminderStatusCancelled		s.logger.Info("booking not found for reminder", "booking_id", r.BookingID)	if booking == nil {	}		}			break			booking = b		if b.GetID() == r.BookingID {	for _, b := range bookings {	var booking Booking	// Find the booking for this reminder	}		return err		s.logger.Error("failed to get booking", "error", err)	if err != nil {	bookings, err := s.service.bookings.GetUpcomingBookings(ctx, 48*time.Hour)	// Get booking	}		return s.service.repo.UpdateReminder(ctx, r)		r.UpdatedAt = time.Now()		r.Status = ReminderStatusCancelled		s.logger.Debug("reminders disabled for user", "user_id", r.UserID)	if !settings.RemindersEnabled {	}		return err		s.logger.Error("failed to get user settings", "user_id", r.UserID, "error", err)	if err != nil {	settings, err := s.service.userSettings.GetUserSettings(ctx, r.UserID)	// Check user settings	defer s.service.repo.ReleaseReminder(ctx, r.ID)	}		return nil		s.logger.Debug("reminder already being processed", "id", r.ID)	if !acquired {	}		return err		s.logger.Error("failed to acquire reminder", "id", r.ID, "error", err)	if err != nil {	acquired, err := s.service.repo.TryAcquireReminder(ctx, r.ID)	// Try to acquire the reminder (for distributed processing)func (s *Scheduler) processReminder(ctx context.Context, r *Reminder) error {// processReminder processes a single reminder.}		"duration", duration)		"failed", stats.failed,		"skipped", stats.skipped,		"sent", stats.sent,		"total", stats.total,	s.logger.Info("daily reminders processed",	duration := time.Since(start)	}		}			stats.sent++		} else {			stats.failed++		if err := s.processReminder(ctx, r); err != nil {		// Process single reminder		}		default:			return				"remaining", stats.total-stats.sent-stats.failed)				"processed", stats.sent+stats.failed,			s.logger.Info("reminder processing interrupted",		case <-ctx.Done():		select {		// Check context cancellation		r := &reminders[i]	for i := range reminders {	s.logger.Info("found pending reminders", "count", stats.total)	stats.total = len(reminders)	}		return		s.logger.Error("failed to fetch pending reminders", "error", err)	if err != nil {	reminders, err := s.service.repo.FindReminders(ctx, filter)	filter.Enabled = &enabled	enabled := true	}		ScheduledAtBefore: &now,		Status:            []ReminderStatus{ReminderStatusPending, ReminderStatusScheduled},	filter := ReminderFilter{	now := time.Now()	// Get pending reminders	}{}		failed  int		skipped int		sent    int		total   int	stats := struct {	start := time.Now()func (s *Scheduler) processDailyReminders(ctx context.Context) {// processDailyReminders processes all pending reminders.}	}		s.cleanupOldReminders(ctx)	if s.config.CleanupEnabled {	// Cleanup old reminders if enabled	s.processDailyReminders(ctx)	// Process reminders	s.mu.Unlock()	s.lastRunDate = today	s.mu.Lock()		"time", now.Format("15:04:05"))		"date", today,	s.logger.Info("starting daily reminder processing",	}		return	if now.Hour() != s.config.DailyHour || now.Minute() != s.config.DailyMinute {	// Check if it's the right time	}		return	if alreadyRan {	s.mu.Unlock()	alreadyRan := s.lastRunDate == today	s.mu.Lock()	today := now.Format("2006-01-02")	now := time.Now().In(s.location)func (s *Scheduler) checkAndRun(ctx context.Context) {// checkAndRun checks if it's time to run and executes if needed.}	}		s.running = false		close(s.stopCh)	if s.running {	defer s.mu.Unlock()	s.mu.Lock()func (s *Scheduler) Stop() {// Stop stops the scheduler.}	}		}			s.checkAndRun(ctx)		case <-ticker.C:			return			s.logger.Info("reminder scheduler stopped")		case <-s.stopCh:			return			s.logger.Info("reminder scheduler stopped by context")		case <-ctx.Done():		select {	for {	defer ticker.Stop()	ticker := time.NewTicker(s.config.CheckInterval)		"daily_time", s.formatTime())		"timezone", s.config.Timezone,	s.logger.Info("reminder scheduler started",	s.mu.Unlock()	s.running = true	}		return		s.mu.Unlock()	if s.running {	s.mu.Lock()func (s *Scheduler) Start(ctx context.Context) {// Start begins the scheduler loop.}	}, nil		stopCh:   make(chan struct{}),		logger:   logger,		location: loc,		sender:   sender,		service:  service,		config:   config,	return &Scheduler{	}		return nil, err	if err != nil {	loc, err := time.LoadLocation(config.Timezone)) (*Scheduler, error) {	logger Logger,	sender *ReminderSender,	service *Service,	config SchedulerConfig,func NewScheduler(// NewScheduler creates a new reminder scheduler.}	stopCh      chan struct{}	running     bool	lastRunDate string // YYYY-MM-DD of last run	mu          sync.Mutex	logger   Logger	location *time.Location	sender   *ReminderSender	service  *Service	config   SchedulerConfigtype Scheduler struct {// Scheduler manages the reminder sending schedule.}	}		CleanupRetentionDays: 1,		CleanupEnabled:       true,		CheckInterval:        1 * time.Minute,		DailyMinute:          0,		DailyHour:            12,		Timezone:             "Europe/Moscow",	return SchedulerConfig{func DefaultSchedulerConfig() SchedulerConfig {// DefaultSchedulerConfig returns the default scheduler configuration.}	CleanupRetentionDays int	// CleanupRetentionDays is how many days to keep sent reminders.	CleanupEnabled bool	// CleanupEnabled enables automatic cleanup of old reminders.	CheckInterval time.Duration	// CheckInterval is how often to check if it's time to run.	DailyMinute int	// DailyMinute is the minute (0-59) when daily reminders are processed.	DailyHour int	// DailyHour is the hour (0-23) when daily reminders are processed.	Timezone string	// Timezone for scheduling (e.g., "Europe/Moscow")type SchedulerConfig struct {// SchedulerConfig holds configuration for the reminder scheduler.)	"time"	"sync"	"context"import (